mcmc_pars <- c("iterations"=200000,"popt"=0.44,"opt_freq"=2000,
"thin"=100,"adaptive_period"=100000,"save_block"=1000)
f <- create_posterior_func(parTab=par_tab,
data=example_ct_data,
INCIDENCE_FUNC=gaussian_process_model,
PRIOR_FUNC=prior_func_gp)
f(par_tab$values)
lik
prior
knitr::opts_chunk$set(eval=TRUE,collapse=TRUE,warning=FALSE,fig.path="man/figures/")
#library(virosolver)
devtools::load_all("~/Documents/GitHub/virosolver")
library(lazymcmc)
library(tidyverse)
library(ggplot2)
## Attach simulated data
data(example_ct_data)
## Attach parameter table for MCMC control
data(example_gp_partab)
## Re-size the parameter control table to fit the data dimensions
## This is for the GP version
times <- 0:max(example_ct_data$t)
mat <- matrix(rep(times, each=length(times)),ncol=length(times))
t_dist <- abs(apply(mat, 2, function(x) x-times)) ## precomputed table of pairwise distances in time, used for the Gaussian process prior
par_tab <- example_gp_partab
par_tab <- bind_rows(par_tab[par_tab$names != "prob",], par_tab[par_tab$names == "prob",][1:length(times),])
pars <- par_tab$values
names(pars) <- par_tab$names
## Pull out the current values for each parameter, and set these as the prior means
means <- par_tab$values
names(means) <- par_tab$names
## Set standard deviations of prior distribution
sds_gp <- c("obs_sd"=0.5,"viral_peak"=2,
"wane_rate2"=1,"t_switch"=3,"level_switch"=1,
"prob_detect"=0.03,
"incubation"=0.25, "infectious"=0.5)
## Define a function that returns the log prior probability for a given vector of parameter
## values in `pars`, given the prior means and standard deviations set above.
## Prior for GP version
prior_func_gp <- function(pars, ...){
par_names <- names(pars)
## Viral kinetics parameters
obs_sd_prior <- dnorm(pars["obs_sd"], means[which(names(means) == "obs_sd")], sds_gp["obs_sd"],log=TRUE)
viral_peak_prior <- dnorm(pars["viral_peak"], means[which(names(means) == "viral_peak")], sds_gp["viral_peak"],log=TRUE)
wane_2_prior <- dnorm(pars["wane_rate2"],means[which(names(means) == "wane_rate2")],sds_gp["wane_rate2"],log=TRUE)
tswitch_prior <- dnorm(pars["t_switch"],means[which(names(means) == "t_switch")],sds_gp["t_switch"],log=TRUE)
level_prior <- dnorm(pars["level_switch"],means[which(names(means) == "level_switch")],sds_gp["level_switch"],log=TRUE)
beta1_mean <- means[which(names(means) == "prob_detect")]
beta1_sd <- sds_gp["prob_detect"]
beta_alpha <- ((1-beta1_mean)/beta1_sd^2 - 1/beta1_mean)*beta1_mean^2
beta_beta <- beta_alpha*(1/beta1_mean - 1)
beta_prior <- dbeta(pars["prob_detect"],beta_alpha,beta_beta,log=TRUE)
#########
## IMPORTANT
## Gaussian process prior, un-centered version
k <- pars[which(par_names=="prob")]
## Leave this - correct for uncentered version as per Chapter 14 Statistical Rethinking
prob_priors <- sum(dnorm(k, 0, 1, log=TRUE))
#########
nu_prior <- dexp(pars["nu"], 1/means[which(names(means) == "nu")],log=TRUE)
rho_prior <- dexp(pars["rho"], 1/means[which(names(means) == "rho")],log=TRUE)
obs_sd_prior + viral_peak_prior + wane_2_prior + tswitch_prior +
level_prior + beta_prior + prob_priors +
nu_prior + rho_prior
}
## MCMC chain options
mcmc_pars <- c("iterations"=200000,"popt"=0.44,"opt_freq"=2000,
"thin"=100,"adaptive_period"=100000,"save_block"=1000)
f <- create_posterior_func(parTab=par_tab,
data=example_ct_data,
INCIDENCE_FUNC=gaussian_process_model,
PRIOR_FUNC=prior_func_gp)
f(par_tab$values)
liks_tj
use_func(obs1, times[i], ages1, pars, prob_infection,sd_mod)
undetectable_lik
ages1
sd_mod
pi
pi*(15/2)^2
pi*(11/2)^2
5000*0.92
2300/(23*5)
devtools::install_github("jameshay218/virosolver")
knitr::opts_chunk$set(eval=TRUE,collapse=TRUE,warning=FALSE)
library(virosolver)
library(tidyverse)
library(patchwork)
library(lazymcmc)
library(foreach)
library(doParallel)
cl <- parallel::makeCluster(4, setup_strategy = "sequential")
registerDoParallel(cl)
data(example_ct_data)
print(head(example_ct_data %>% filter(ct < 40)))
## Plot only detectable Ct values
p_ct_data <- ggplot(example_ct_data %>% filter(ct < 40)) +
geom_violin(aes(x=t,group=t,y=ct),scale="width",fill="grey70",draw_quantiles=c(0.025,0.5,0.975)) +
geom_jitter(aes(x=t,y=ct),size=0.1,width=2,height=0) +
scale_y_continuous(trans="reverse") +
theme_bw() +
ylab("Ct value") +
xlab("Observation time") +
ggtitle("Observed Ct values < 40 (the limit of detection) over time")
p_ct_data
p_detectable_data <- example_ct_data %>%
mutate(detect=ct < 40) %>%
group_by(t) %>%
summarize(prev=sum(detect)/n()) %>%
ggplot() + geom_point(aes(x=t,y=prev)) +
theme_bw() +
scale_y_continuous(limits=c(0,0.6)) +
ylab("Proportion detectable") +
ggtitle("Proportion of samples with Ct values < 40") +
xlab("Observation time")
p_detectable_data
data(example_gp_partab)
pars <- example_gp_partab$values
names(pars) <- example_gp_partab$names
## Solve the Ct model over a range of times since infection (referred to as "ages")
test_ages <- seq(1,50,by=1)
## This gives the modal Ct value
cts <- viral_load_func(pars, test_ages)
p_ct_model <- ggplot(data.frame(ct=c(40,cts),t=c(0,test_ages))) +
geom_line(aes(x=t,y=ct)) +
scale_y_continuous(trans="reverse",
limits=c(40,10)) +
theme_bw() +
ylab("Modal Ct value") +
xlab("Days since infection")
## Note that this model does not solve for t=0,
## as it is always assumed that no one is detectable 0 days post infection
prop_detect <- prop_detectable(test_ages,pars, cts)
p_ct_model_detectable <- ggplot(data.frame(p=c(0,prop_detect),t=c(0,test_ages))) +
geom_line(aes(x=t,y=p)) +
theme_bw() +
ylab("Proportion of infections\n still detectable") +
xlab("Days since infection")
p_ct_model/p_ct_model_detectable
sim_cts <- simulate_viral_loads_example(test_ages, pars,N=200)
print(head(sim_cts))
p_sim_cts_age <- ggplot(sim_cts %>% filter(ct < 40)) +
geom_point(aes(x=age,y=ct),alpha=0.25) +
scale_y_continuous(trans="reverse",limits=c(40,10)) +
theme_bw() +
ylab("Ct value") +
xlab("Days since infection") +
ggtitle("Simulated detectable Ct values on each day post infection")
p_sim_cts_age
data(example_gp_partab)
head(example_gp_partab)
## Illustration -- set the `viral_peak` parameter to be estimated during the procedure, and the `intercept` parameter to be fixed
example_gp_partab <- example_gp_partab %>% filter(names == "viral_peak") %>% mutate(fixed=0)
example_gp_partab <- example_gp_partab %>% filter(names == "intercept") %>% mutate(fixed=1)
## Read in the SEIR model parameter control table
data(example_seir_partab)
## Pull out the current values for each parameter, and set these as the prior means
means <- example_seir_partab$values
names(means) <- example_seir_partab$names
## Set standard deviations of prior distribution
sds_seir <- c("obs_sd"=0.5,"viral_peak"=2,
"wane_rate2"=1,"t_switch"=3,"level_switch"=1,
"prob_detect"=0.03,
"incubation"=0.25, "infectious"=0.5)
## Define a function that returns the log prior probability for a given vector of parameter
## values in `pars`, given the prior means and standard deviations set above.
prior_func_seir <- function(pars,...){
## Ct model priors
obs_sd_prior <- dnorm(pars["obs_sd"], means[which(names(means) == "obs_sd")], sds_seir["obs_sd"],log=TRUE)
viral_peak_prior <- dnorm(pars["viral_peak"], means[which(names(means) == "viral_peak")], sds_seir["viral_peak"],log=TRUE)
wane_2_prior <- dnorm(pars["wane_rate2"],means[which(names(means) == "wane_rate2")],sds_seir["wane_rate2"],log=TRUE)
tswitch_prior <- dnorm(pars["t_switch"],means[which(names(means) == "t_switch")],sds_seir["t_switch"],log=TRUE)
level_prior <- dnorm(pars["level_switch"],means[which(names(means) == "level_switch")],sds_seir["level_switch"],log=TRUE)
## Beta prior on the prob_detect parameter to ensure between 0 and 1
beta1_mean <- means[which(names(means) == "prob_detect")]
beta1_sd <- sds_seir["prob_detect"]
beta_alpha <- ((1-beta1_mean)/beta1_sd^2 - 1/beta1_mean)*beta1_mean^2
beta_beta <- beta_alpha*(1/beta1_mean - 1)
beta_prior <- dbeta(pars["prob_detect"],beta_alpha,beta_beta,log=TRUE)
## SEIR model priors
incu_prior <- dlnorm(pars["incubation"],log(means[which(names(means) == "incubation")]), sds_seir["incubation"], TRUE)
infectious_prior <- dlnorm(pars["infectious"],log(means[which(names(means) == "infectious")]),sds_seir["infectious"],TRUE)
## Sum up
obs_sd_prior + viral_peak_prior +
wane_2_prior + tswitch_prior + level_prior + beta_prior +
incu_prior + infectious_prior
}
## Point to a function that expects a vector of named parameters and returns a vector of daily infection probabilities/incidence
incidence_function <- solveSEIRModel_lsoda_wrapper
## Use the example parameter table
data(example_seir_partab)
## Create the posterior function used in the MCMC framework
posterior_func <- create_posterior_func(parTab=example_seir_partab,
data=example_ct_data,
PRIOR_FUNC=prior_func_seir,
INCIDENCE_FUNC=incidence_function,
use_pos=FALSE) ## Important argument, see text
## Test with default parameters to find the log likelihood
posterior_func(example_seir_partab$values)
library(virosolver)
dgumbel_jh
knitr::opts_chunk$set(eval=TRUE,collapse=TRUE,warning=FALSE)
library(virosolver)
library(tidyverse)
library(patchwork)
library(lazymcmc)
library(foreach)
library(doParallel)
cl <- parallel::makeCluster(4, setup_strategy = "sequential")
registerDoParallel(cl)
data(example_ct_data)
print(head(example_ct_data %>% filter(ct < 40)))
## Plot only detectable Ct values
p_ct_data <- ggplot(example_ct_data %>% filter(ct < 40)) +
geom_violin(aes(x=t,group=t,y=ct),scale="width",fill="grey70",draw_quantiles=c(0.025,0.5,0.975)) +
geom_jitter(aes(x=t,y=ct),size=0.1,width=2,height=0) +
scale_y_continuous(trans="reverse") +
theme_bw() +
ylab("Ct value") +
xlab("Observation time") +
ggtitle("Observed Ct values < 40 (the limit of detection) over time")
p_ct_data
p_detectable_data <- example_ct_data %>%
mutate(detect=ct < 40) %>%
group_by(t) %>%
summarize(prev=sum(detect)/n()) %>%
ggplot() + geom_point(aes(x=t,y=prev)) +
theme_bw() +
scale_y_continuous(limits=c(0,0.6)) +
ylab("Proportion detectable") +
ggtitle("Proportion of samples with Ct values < 40") +
xlab("Observation time")
p_detectable_data
data(example_gp_partab)
pars <- example_gp_partab$values
names(pars) <- example_gp_partab$names
## Solve the Ct model over a range of times since infection (referred to as "ages")
test_ages <- seq(1,50,by=1)
## This gives the modal Ct value
cts <- viral_load_func(pars, test_ages)
p_ct_model <- ggplot(data.frame(ct=c(40,cts),t=c(0,test_ages))) +
geom_line(aes(x=t,y=ct)) +
scale_y_continuous(trans="reverse",
limits=c(40,10)) +
theme_bw() +
ylab("Modal Ct value") +
xlab("Days since infection")
## Note that this model does not solve for t=0,
## as it is always assumed that no one is detectable 0 days post infection
prop_detect <- prop_detectable(test_ages,pars, cts)
p_ct_model_detectable <- ggplot(data.frame(p=c(0,prop_detect),t=c(0,test_ages))) +
geom_line(aes(x=t,y=p)) +
theme_bw() +
ylab("Proportion of infections\n still detectable") +
xlab("Days since infection")
p_ct_model/p_ct_model_detectable
sim_cts <- simulate_viral_loads_example(test_ages, pars,N=200)
print(head(sim_cts))
p_sim_cts_age <- ggplot(sim_cts %>% filter(ct < 40)) +
geom_point(aes(x=age,y=ct),alpha=0.25) +
scale_y_continuous(trans="reverse",limits=c(40,10)) +
theme_bw() +
ylab("Ct value") +
xlab("Days since infection") +
ggtitle("Simulated detectable Ct values on each day post infection")
p_sim_cts_age
data(example_gp_partab)
head(example_gp_partab)
## Illustration -- set the `viral_peak` parameter to be estimated during the procedure, and the `intercept` parameter to be fixed
example_gp_partab <- example_gp_partab %>% filter(names == "viral_peak") %>% mutate(fixed=0)
example_gp_partab <- example_gp_partab %>% filter(names == "intercept") %>% mutate(fixed=1)
## Read in the SEIR model parameter control table
data(example_seir_partab)
## Pull out the current values for each parameter, and set these as the prior means
means <- example_seir_partab$values
names(means) <- example_seir_partab$names
## Set standard deviations of prior distribution
sds_seir <- c("obs_sd"=0.5,"viral_peak"=2,
"wane_rate2"=1,"t_switch"=3,"level_switch"=1,
"prob_detect"=0.03,
"incubation"=0.25, "infectious"=0.5)
## Define a function that returns the log prior probability for a given vector of parameter
## values in `pars`, given the prior means and standard deviations set above.
prior_func_seir <- function(pars,...){
## Ct model priors
obs_sd_prior <- dnorm(pars["obs_sd"], means[which(names(means) == "obs_sd")], sds_seir["obs_sd"],log=TRUE)
viral_peak_prior <- dnorm(pars["viral_peak"], means[which(names(means) == "viral_peak")], sds_seir["viral_peak"],log=TRUE)
wane_2_prior <- dnorm(pars["wane_rate2"],means[which(names(means) == "wane_rate2")],sds_seir["wane_rate2"],log=TRUE)
tswitch_prior <- dnorm(pars["t_switch"],means[which(names(means) == "t_switch")],sds_seir["t_switch"],log=TRUE)
level_prior <- dnorm(pars["level_switch"],means[which(names(means) == "level_switch")],sds_seir["level_switch"],log=TRUE)
## Beta prior on the prob_detect parameter to ensure between 0 and 1
beta1_mean <- means[which(names(means) == "prob_detect")]
beta1_sd <- sds_seir["prob_detect"]
beta_alpha <- ((1-beta1_mean)/beta1_sd^2 - 1/beta1_mean)*beta1_mean^2
beta_beta <- beta_alpha*(1/beta1_mean - 1)
beta_prior <- dbeta(pars["prob_detect"],beta_alpha,beta_beta,log=TRUE)
## SEIR model priors
incu_prior <- dlnorm(pars["incubation"],log(means[which(names(means) == "incubation")]), sds_seir["incubation"], TRUE)
infectious_prior <- dlnorm(pars["infectious"],log(means[which(names(means) == "infectious")]),sds_seir["infectious"],TRUE)
## Sum up
obs_sd_prior + viral_peak_prior +
wane_2_prior + tswitch_prior + level_prior + beta_prior +
incu_prior + infectious_prior
}
## Point to a function that expects a vector of named parameters and returns a vector of daily infection probabilities/incidence
incidence_function <- solveSEIRModel_lsoda_wrapper
## Use the example parameter table
data(example_seir_partab)
## Create the posterior function used in the MCMC framework
posterior_func <- create_posterior_func(parTab=example_seir_partab,
data=example_ct_data,
PRIOR_FUNC=prior_func_seir,
INCIDENCE_FUNC=incidence_function,
use_pos=FALSE) ## Important argument, see text
## Test with default parameters to find the log likelihood
posterior_func(example_seir_partab$values)
dgumbel_jh
?create
devtools::install_github("jameshay218/antibodyKinetics")
paramViewer()
runApp()
getwd()
library(antibodyKinetics)
paramViewer()
install.packages("shinyBS")
paramViewer()
install.packages("rhandsontable")
paramViewer()
version()
R.version
library(serosolver)
library(plyr)
library(data.table)
library(ggplot2)
## Load in example parameter values and antigenic map
data(example_par_tab)
data(example_antigenic_map)
## Get all possible infection times
strain_isolation_times <- unique(example_antigenic_map$inf_times)
## Vector of strains that have titres (note only one representative strain per time)
sampled_viruses <- seq(min(strain_isolation_times), max(strain_isolation_times), by=2)
## Times at which serum samples can be taken
sampling_times <- 2010:2015
## Number of serum samples taken
n_samps <- 2
## Simulate some random attack rates
attack_rates <- runif(length(strain_isolation_times), 0.05, 0.15)
## Simulate a full serosurvey with these parameters
all_simulated_data <- simulate_data(par_tab=example_par_tab, group=1, n_indiv=50,
strain_isolation_times=strain_isolation_times,
measured_strains=sampled_viruses,
sampling_times=2010:2015, nsamps=n_samps,
antigenic_map=example_antigenic_map,
age_min=10,age_max=75,
attack_rates=attack_rates, repeats=2)
library(serosolver)
library(plyr)
library(data.table)
library(ggplot2)
## Load in example parameter values and antigenic map
data(example_par_tab)
data(example_antigenic_map)
## Get all possible infection times
strain_isolation_times <- unique(example_antigenic_map$inf_times)
## Vector of strains that have titres (note only one representative strain per time)
sampled_viruses <- seq(min(strain_isolation_times), max(strain_isolation_times), by=2)
## Times at which serum samples can be taken
sampling_times <- 2010:2015
## Number of serum samples taken
n_samps <- 2
## Simulate some random attack rates
attack_rates <- runif(length(strain_isolation_times), 0.05, 0.15)
## Simulate a full serosurvey with these parameters
all_simulated_data <- simulate_data(par_tab=example_par_tab, group=1, n_indiv=50,
strain_isolation_times=strain_isolation_times,
measured_strains=sampled_viruses,
sampling_times=2010:2015, nsamps=n_samps,
antigenic_map=example_antigenic_map,
age_min=10,age_max=75,
attack_rates=attack_rates, repeats=2)
## Pull out the simulated titre data and infection histories
titre_dat <- all_simulated_data$data
ages <- all_simulated_data$ages
example_inf_hist <- all_simulated_data$infection_histories
example_titre_dat <- merge(titre_dat, ages)
## Run the MCMC
# This example uses prior version 2 (i.e. beta prior on phi with parameters alpha, beta)
# We have to remove the explicit specification of phi in the parameter table
par_tab <- example_par_tab[example_par_tab$names != "phi",]
res <- run_MCMC(par_tab, example_titre_dat, example_antigenic_map,
filename="test", version=2,
mcmc_pars=c(adaptive_period=20000, iterations=80000,
inf_propn=0.5,hist_sample_prob=0.5,
save_block=10000,thin=10,thin_hist=100))
devtools::install_github("seroanalytics/serosolver@8270dc623ed333060388aef4ecf870d16990ed98")
devtools::install_github("seroanalytics/serosolver@8270dc623ed333060388aef4ecf870d16990ed98",force=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
simulate_individual_faster
# Plot model predicted titres for a subset of individuals
plot_infection_histories_long(chain = chain,infection_histories = inf_chain,
titre_dat = example_titre_dat,individuals=c(1:4),
antigenic_map=example_antigenic_map,par_tab=par_tab)
library(ggpubr)
# Plot model predicted titres for a subset of individuals
plot_infection_histories_long(chain = chain,infection_histories = inf_chain,
titre_dat = example_titre_dat,individuals=c(1:4),
antigenic_map=example_antigenic_map,par_tab=par_tab)
# Plot model predicted titres for a subset of individuals
plot_infection_histories_long(chain = chain,infection_histories = inf_chain,
titre_dat = example_titre_dat,individuals=c(1:4),
antigenic_map=example_antigenic_map,par_tab=par_tab)
library(serosolver)
library(plyr)
library(data.table)
library(ggplot2)
library(ggpubr)
## Load in example parameter values and antigenic map
data(example_par_tab)
data(example_antigenic_map)
## Get all possible infection times
strain_isolation_times <- unique(example_antigenic_map$inf_times)
## Vector of strains that have titres (note only one representative strain per time)
sampled_viruses <- seq(min(strain_isolation_times), max(strain_isolation_times), by=2)
## Times at which serum samples can be taken
sampling_times <- 2010:2015
## Number of serum samples taken
n_samps <- 2
## Simulate some random attack rates
attack_rates <- runif(length(strain_isolation_times), 0.05, 0.15)
## Simulate a full serosurvey with these parameters
all_simulated_data <- simulate_data(par_tab=example_par_tab, group=1, n_indiv=50,
strain_isolation_times=strain_isolation_times,
measured_strains=sampled_viruses,
sampling_times=2010:2015, nsamps=n_samps,
antigenic_map=example_antigenic_map,
age_min=10,age_max=75,
attack_rates=attack_rates, repeats=2)
## Pull out the simulated titre data and infection histories
titre_dat <- all_simulated_data$data
ages <- all_simulated_data$ages
example_inf_hist <- all_simulated_data$infection_histories
example_titre_dat <- merge(titre_dat, ages)
## Run the MCMC
# This example uses prior version 2 (i.e. beta prior on phi with parameters alpha, beta)
# We have to remove the explicit specification of phi in the parameter table
par_tab <- example_par_tab[example_par_tab$names != "phi",]
res <- run_MCMC(par_tab, example_titre_dat, example_antigenic_map,
filename="test", version=2,
mcmc_pars=c(adaptive_period=20000, iterations=80000,
inf_propn=0.5,hist_sample_prob=0.5,
save_block=10000,thin=10,thin_hist=100))
## Read in the MCMC chains and plot posteriors
chain <- read.csv(res$chain_file)
inf_chain <- data.table::fread(res$history_file)
plot(coda::as.mcmc(chain[chain$sampno > 20000,c("mu","wane","lnlike")]))
# Plot model predicted titres for a subset of individuals
plot_infection_histories_long(chain = chain,infection_histories = inf_chain,
titre_dat = example_titre_dat,individuals=c(1:4),
antigenic_map=example_antigenic_map,par_tab=par_tab)
plot(coda::as.mcmc(chain[chain$sampno > 20000,c("mu","wane","lnlike")]))
# Plot model predicted titres for a subset of individuals
plot_infection_histories_long(chain = chain,infection_histories = inf_chain,
titre_dat = example_titre_dat,individuals=c(1:4),
antigenic_map=example_antigenic_map,par_tab=par_tab)
inf_chain
# Plot model predicted titres for a subset of individuals
plot_infection_histories_long(chain = chain,infection_histories = inf_chain,
titre_dat = example_titre_dat,individuals=c(1:4),
antigenic_map=example_antigenic_map,par_tab=par_tab)
plot_infection_histories_long
plot_infection_histories(chain = chain,infection_histories = inf_chain,
titre_dat = example_titre_dat,individuals=c(1:4),
antigenic_map=example_antigenic_map,par_tab=par_tab)
?plot_infection_histories
write_csv("~/Google Drive/Teaching/Pandemic Exercise/outputs/full_epi_curve.csv",epi_curve_full)
source('/Volumes/GoogleDrive/My Drive/Teaching/Pandemic Exercise/simulation_script.R', echo=TRUE)
0.00001*1000000
age_pars%>%mutate(i=0:(n()-1))
to_process %>% filter(reported==1) %>% dplyr::filter(report_date <= as.Date(t_report1-7,origin="2022-07-01"))  %>% group_by(age_group) %>% tally()
to_process
head(to_process)
source('/Volumes/GoogleDrive/My Drive/Teaching/Pandemic Exercise/simulation_script.R', echo=TRUE)
epi_curve_1 <- to_process %>%dplyr::filter(reported==1) %>%
dplyr::filter(report_date <= as.Date(t_report1,origin="2022-07-01")) %>%
group_by(report_date, age,age_group) %>%
rename(`Age group`=age_group) %>%
tally()
write_csv("~/Google Drive/Teaching/Pandemic Exercise/outputs/epi_curve_1.csv",epi_curve_1)
?write_csv
source('/Volumes/GoogleDrive/My Drive/Teaching/Pandemic Exercise/simulation_script.R', echo=TRUE)
epi_curve_full <- to_process %>%
dplyr::filter(onset_date <= as.Date(t_report2,origin="2022-07-01")) %>%
group_by(onset_date, age,age_group) %>%
rename(`Age group`=age_group) %>%
tally()
write_csv(epi_curve_full,"~/Google Drive/Teaching/Pandemic Exercise/outputs/full_epi_curve.csv")
epi_curve_full <- to_process %>%
dplyr::filter(onset_date <= as.Date(t_report2,origin="2022-07-01")) %>%
group_by(onset_date) %>%
tally()
epi_curve_full_infections <- to_process %>%
dplyr::filter(infection_date <= as.Date(t_report2,origin="2022-07-01")) %>%
group_by(infection_date) %>%
tally()
write_csv(epi_curve_full,"~/Google Drive/Teaching/Pandemic Exercise/outputs/full_epi_curve.csv")
write_csv(epi_curve_full_infections,"~/Google Drive/Teaching/Pandemic Exercise/outputs/full_epi_curve_infections.csv")
epi_curve_full
popN
hostPopn
hostPopn[1]
nrow(viruses)
nrow(hosts)
